[{"authors":["admin"],"categories":null,"content":"我是杜利强，现在是友信金服科技有限公司的一名软件工程师，曾在新浪微博担任搜索算法工程师，在诺禾致源担任生物信息软件开发工程师。我的兴趣包括互联网金融风控、信息检索排序、推荐系统。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://keris.github.io/zh/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/zh/authors/admin/","section":"authors","summary":"我是杜利强，现在是友信金服科技有限公司的一名软件工程师，曾在新浪微博担任搜索算法工程师，在诺禾致源担任生物信息软件开发工程师。我的兴趣包括互联网金融风控、信息检索排序、推荐系统。","tags":null,"title":"杜利强","type":"authors"},{"authors":[],"categories":[],"content":"RFM是一种用于分析客户价值的方法，常用于营销。其中RFM代表三个维度：\n Recency 表示最近一次客户购买的时间 Frequency 表示在统计周期内客户购买的次数 Monetary Value 表示统计周期内客户消费的总金额  接下来，我们使用RFM模型分析一个真实的在线购物数据。\n# Import libraries import pandas as pd import matplotlib.pyplot as plt import squarify from datetime import timedelta import seaborn as sns  # Read dataset online = pd.read_csv('data.csv', encoding='ISO-8859-1') online.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  \n  InvoiceNo StockCode Description Quantity InvoiceDate UnitPrice CustomerID Country     0 536365 85123A WHITE HANGING HEART T-LIGHT HOLDER 6 12/1/2010 8:26 2.55 17850.0 United Kingdom   1 536365 71053 WHITE METAL LANTERN 6 12/1/2010 8:26 3.39 17850.0 United Kingdom   2 536365 84406B CREAM CUPID HEARTS COAT HANGER 8 12/1/2010 8:26 2.75 17850.0 United Kingdom   3 536365 84029G KNITTED UNION FLAG HOT WATER BOTTLE 6 12/1/2010 8:26 3.39 17850.0 United Kingdom   4 536365 84029E RED WOOLLY HOTTIE WHITE HEART. 6 12/1/2010 8:26 3.39 17850.0 United Kingdom     online.dtypes  InvoiceNo object StockCode object Description object Quantity int64 InvoiceDate object UnitPrice float64 CustomerID float64 Country object dtype: object  # Convert InvoiceDate from object to datetime format online['InvoiceDate'] = pd.to_datetime(online['InvoiceDate'])  online.dtypes  InvoiceNo object StockCode object Description object Quantity int64 InvoiceDate datetime64[ns] UnitPrice float64 CustomerID float64 Country object dtype: object  # Check how many rows and columns online.shape  (541909, 8)  # Count transactions that don't have a customer id print('{:,} transactions don\\'t have a customer id' .format(online[online.CustomerID.isnull()].shape[0]))  135,080 transactions don't have a customer id  # Check invoice date range print('Transactions timeframe from {} to {}' .format(online.InvoiceDate.min(), online.InvoiceDate.max()))  Transactions timeframe from 2010-12-01 08:26:00 to 2011-12-09 12:50:00  # Drop NA values from online online.dropna(inplace=True)  # Group data by CustomerID # Create TotalSum column for online dataset online['TotalSum'] = online['Quantity'] * online['UnitPrice'] # Create snapshot date snapshot_date = online.InvoiceDate.max() + timedelta(days=1) print(snapshot_date) # Group by CustomerID data = online.groupby(['CustomerID']).agg({ 'InvoiceDate': lambda x: (snapshot_date - x.max()).days, 'InvoiceNo': 'count', 'TotalSum': 'sum' }) data.rename(columns={'InvoiceDate': 'Recency', 'InvoiceNo': 'Frequency', 'TotalSum': 'MonetaryValue'}, inplace=True)  2011-12-10 12:50:00  # Peek first 5 rows data.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  \n  Recency Frequency MonetaryValue   CustomerID        12346.0 326 2 0.00   12347.0 2 182 4310.00   12348.0 75 31 1797.24   12349.0 19 73 1757.55   12350.0 310 17 334.40     # Check how many rows and columns data.shape  (4372, 3)  在这里我们可以看到，根据CutomerID进行分组后，我们聚合生成了每个客户最近一次购买的时间，购买频率和消费额度，共4372条记录。接下来，我们需要对这三个维度进行打分，这可以通过.qcut()来进行。但在此之前，我们先看一看特征的分布情况。\n# Plot RFM distributions plt.figure(figsize=(12,10)) # Plot distribution of R plt.subplot(3, 1, 1) sns.distplot(data['Recency']) # Plot distribution of F plt.subplot(3, 1, 2) sns.distplot(data['Frequency']) # Plot distribution of M plt.subplot(3, 1, 3) sns.distplot(data['MonetaryValue'])  \u0026lt;matplotlib.axes._subplots.AxesSubplot at 0x1199779b0\u0026gt;  # Calculate R and F groups # Create labels for Recency and Frequency r_labels = range(4, 0, -1) f_labels = range(1, 5) # Assign these labels to 4 equal percentil groups r_groups = pd.qcut(data['Recency'], q=4, labels=r_labels) f_groups = pd.qcut(data['Frequency'], q=4, labels=f_labels) # Create new columns R and F data = data.assign(R=r_groups.values, F=f_groups.values) data.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  \n  Recency Frequency MonetaryValue R F   CustomerID          12346.0 326 2 0.00 1 1   12347.0 2 182 4310.00 4 4   12348.0 75 31 1797.24 2 2   12349.0 19 73 1757.55 3 3   12350.0 310 17 334.40 1 1     # Create labels form MonetaryValue m_labels = range(1, 5) m_groups = pd.qcut(data['MonetaryValue'], q=4, labels=m_labels) data = data.assign(M=m_groups.values)  data.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  \n  Recency Frequency MonetaryValue R F M   CustomerID           12346.0 326 2 0.00 1 1 1   12347.0 2 182 4310.00 4 4 4   12348.0 75 31 1797.24 2 2 4   12349.0 19 73 1757.55 3 3 4   12350.0 310 17 334.40 1 1 2     # Concat RFM quartile values to create RFM segments def join_rfm(x): return str(x['R']) + str(x['F']) + str(x['M']) data['RFM_segment_concat'] = data.apply(join_rfm, axis=1) rfm = data rfm.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  \n  Recency Frequency MonetaryValue R F M RFM_segment_concat   CustomerID            12346.0 326 2 0.00 1 1 1 111   12347.0 2 182 4310.00 4 4 4 444   12348.0 75 31 1797.24 2 2 4 224   12349.0 19 73 1757.55 3 3 4 334   12350.0 310 17 334.40 1 1 2 112     # Count num of unique segments rfm_count_unique = rfm.groupby('RFM_segment_concat')['RFM_segment_concat'].nunique() print(rfm_count_unique.sum())  62  以上结果显示，将RFM连接在一起这种方法共形成62个划分，但划分太多了不能用于实际应用。下面我们尝试将这三个值相加。\n# Calculate RFM_Score rfm['RFM_Score'] = rfm[['R', 'F', 'M']].sum(axis=1) print(rfm['RFM_Score'].head())  CustomerID 12346.0 3.0 12347.0 12.0 12348.0 8.0 12349.0 10.0 12350.0 4.0 Name: RFM_Score, dtype: float64  # Define rfm_level function def rfm_level(df): if df['RFM_Score'] \u0026gt;= 9: return 'Can\\'t Loose Them' elif ((df['RFM_Score'] \u0026gt;= 8) and (df['RFM_Score'] \u0026lt; 9)): return 'Champions' elif ((df['RFM_Score'] \u0026gt;= 7) and (df['RFM_Score'] \u0026lt; 8)): return 'Loyal' elif ((df['RFM_Score'] \u0026gt;= 6) and (df['RFM_Score'] \u0026lt; 7)): return 'Potential' elif ((df['RFM_Score'] \u0026gt;= 5) and (df['RFM_Score'] \u0026lt; 6)): return 'Promising' elif ((df['RFM_Score'] \u0026gt;= 4) and (df['RFM_Score'] \u0026lt; 5)): return 'Needs Attention' else: return 'Require Activation' # Create a new variable RFM_Level rfm['RFM_Level'] = rfm.apply(rfm_level, axis=1) rfm.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  \n  Recency Frequency MonetaryValue R F M RFM_segment_concat RFM_Score RFM_Level   CustomerID              12346.0 326 2 0.00 1 1 1 111 3.0 Require Activation   12347.0 2 182 4310.00 4 4 4 444 12.0 Can't Loose Them   12348.0 75 31 1797.24 2 2 4 224 8.0 Champions   12349.0 19 73 1757.55 3 3 4 334 10.0 Can't Loose Them   12350.0 310 17 334.40 1 1 2 112 4.0 Needs Attention     # Calculate average values for each RFM_Level, and return a size of each segment rfm_level_agg = rfm.groupby('RFM_Level').agg({ 'Recency': 'mean', 'Frequency': 'mean', 'MonetaryValue': ['mean', 'count'] }).round(1) # Print the aggregate dataset print(rfm_level_agg)   Recency Frequency MonetaryValue mean mean mean count RFM_Level Can't Loose Them 25.2 195.1 4130.3 1690 Champions 62.7 57.0 974.7 467 Loyal 78.8 39.7 724.2 447 Needs Attention 174.5 13.9 227.1 391 Potential 94.3 28.5 491.8 468 Promising 153.0 21.2 346.8 517 Require Activation 264.8 7.8 109.1 392  从以上结果我们可以看到，约60%的客户属于优质客户（前三类用户）。\n# Visualize segments rfm_level_agg.columns = rfm_level_agg.columns.droplevel() rfm_level_agg.columns = ['RecencyMean', 'FrequencyMean', 'MonetaryMean', 'Count']  # Create our plot and resize it fig = plt.gcf() ax = fig.add_subplot() fig.set_size_inches(16, 9) squarify.plot(sizes=rfm_level_agg['Count'], label=list(rfm_level_agg.index), alpha=.6) plt.title('RFM Segments', fontsize=18, fontweight='bold') plt.axis('off') plt.show()  ","date":1582702890,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1582702890,"objectID":"ef833db58e604d147197982b1096f887","permalink":"https://keris.github.io/zh/post/what-is-rfm-model/","publishdate":"2020-02-26T15:41:30+08:00","relpermalink":"/zh/post/what-is-rfm-model/","section":"post","summary":"简要说明RFM模型并给出一个实际的使用例子","tags":["RFM"],"title":"RFM模型及实践","type":"post"},{"authors":["杜利强"],"categories":["机器学习"],"content":"目录  术语  Logistic function Odds Logit function   逻辑回归  代价函数求导     术语 逻辑回归涉及到以下术语：\n Logistic function Odds Logit  Logistic function 逻辑回归中的 Logistic 正是出于 Logistic function ，它是一种 sigmoid function ，其接受任意实值，输出一个0到1之间的值。 标准的 logistic funtion 定义如下：\n$$\\sigma(z) = \\frac{e^z}{e^z + 1} = \\frac{1}{1 + e^{-z}}$$\n如下是它在区间$[-6, 6]$之间的图像：\n\n在逻辑回归中，我们使用对数几率（log odds），并假定它是输入特征的线性组合：\n$$z = \\ln \\frac{p(x)}{1 - p(x)}= \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 = \\theta^T \\cdot x$$\n由上式我们可以得到，\n$$p(x) = \\sigma(z) = \\frac{1}{1 + e^{-\\theta^T \\cdot x}}$$\n在逻辑回归模型中，这里的 $p(x)$ 为因变量在成功情形下的概率，即 $p(y=1 \\mid x)$。\nOdds 如果 $p$ 表示一个事件发生的概率，那么odds定义为\n$$\\text{odds} = \\frac{p}{1 - p}$$ 也就是说，odds为发生的概率除以不发生的概率，亦可以说为成功的概率除以失败的概率。\nLogit function Logit为Log odds, logit function 定义为 logistic function的逆，即 $g = \\sigma^{-1}$。显而易见，我们有\n$$g(p(x)) = \\sigma_{-1}(p(x)) = \\text{logit}\\,p(x) = \\ln(\\frac{p(x)}{1 - p(x)}) = \\theta^T \\cdot x$$\n逻辑回归 逻辑回归是一个重要的机器学习算法，其目标是基于给定的数据$x$输出随机变量$y$为0或1的概率。\n考虑由$\\theta$参数化的线性模型，\n$$h_\\theta(x) = \\frac{1}{1 + e^{-\\theta^T \\cdot x}} = \\text{Pr}(y = 1 \\mid x;\\theta)$$\n从而，$\\text{Pr}(y=0 \\mid x;\\theta) = 1 - h_\\theta(x)$。\n因为$y \\in \\{0, 1 \\}$，我们有\n$$\\text{Pr}(y \\mid x;\\theta) = h_\\theta(x)^y (1 - h_\\theta(x))^{1 - y} $$\n似然函数为\n$$\\begin{aligned} L(\\theta \\mid x) \u0026amp;= \\Pr(Y\\mid X;\\theta) \\\\\n\u0026amp;= \\prod_i \\Pr(y^{(i)} \\mid x^{(i)};\\theta) \\\\\n\u0026amp;= \\prod_i h_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}} \\end{aligned}$$\n一般地，我们最大化对数似然函数，\n$$\\log L(\\theta \\mid x) = \\sum_{i=1}^{m}\\log \\Pr(y^{(i)} \\mid x^{(i)};\\theta)$$\n定义代价函数如下：\n$$J(\\theta) = -\\frac{1}{m} \\log L(\\theta \\mid x) = -\\frac{1}{m} \\sum_i^m (y^{(i)} \\log h_\\theta(x^{(i)}) + (1 - y^{(i)})(1 - h_\\theta(x^{(i)})))$$\n容易看到，我们最大化对数似然函数就是最小化代价函数 $J(\\theta)$。在机器学习中，我们使用梯度下降最小化代价函数。\n代价函数求导 下面我们对代价函数$J(\\theta)$对$\\theta$进行求导，我们先考虑在一个样本上的代价函数\n$$J_1(\\theta) = -y \\log h_\\theta(x) - (1 - y)(1 - h_\\theta(x))$$\n现在对$J_1(\\theta)$对$\\theta$进行求导：\n注意到$\\frac{d\\sigma(z)}{dz} = \\sigma(z) (1 - \\sigma(z))$, 我们有\n$$\\begin{aligned}\\frac{\\partial}{\\partial \\theta_j} J_1(\\theta) \u0026amp;= -y \\frac{1}{h_\\theta(x)} h_\\theta(x) (1 - h_\\theta(x)) x_j - (1 - y) \\frac{1}{1 - h_\\theta(x)} (-1) h_\\theta(x) (1 - h_\\theta(x)) x_j \\\\ \u0026amp;= (h_\\theta(x) - y) x_j\\end{aligned} $$\n有了以上结果，我们有\n$$\\frac{\\partial}{\\partial \\theta_j} J(\\theta) = \\frac{1}{m}\\sum_i^m [h_\\theta(x^{(i)}) - y^{(i)}]x_j^{(i)}$$\n","date":1578991642,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1579496437,"objectID":"aebccbb495f02050f938f27e4bd41ef9","permalink":"https://keris.github.io/zh/post/logistic-regression/","publishdate":"2020-01-14T16:47:22+08:00","relpermalink":"/zh/post/logistic-regression/","section":"post","summary":"理解逻辑回归中涉及的术语以及从最大似然到最小化代价函数","tags":["logistic-regression","逻辑回归"],"title":"逻辑回归（Logistic Regression）","type":"post"},{"authors":[],"categories":[],"content":"在git的日常使用中更改提交的作者名和邮箱是一个十分常见的操作。例如，当你克隆了一个项目，如果你没有进行任何设置，此时提交的作者和邮件将使用全局选项，这可能不是你所要的。\n通过本文你将了解：\n 如何配置git使用的提交者用户名和邮箱 如何更改最近一次提交的作者名和邮件 批量更改提交的作者名和邮件  配置提交者用户名和邮箱 你有两种方式进行设置，一是全局配置，二是为每个repo单独配置。\n全局地更改提交者用户名和邮箱 使用git config并--global选项进行全局设置，如下所示：\n$ git config --global user.name \u0026quot;Du Liqiang\u0026quot; $ git config --global user.email \u0026quot;dlq137@gmail.com\u0026quot;  设置完毕后，后续的提交将使用以上提供的信息。\n为某个repo单独配置 全局选项可能并不适用于某个repo，此时就需要单独设置，使用git config但省略--global选项，如下：\n$ git config user.name \u0026quot;Du Liqiang\u0026quot; $ git config user.email \u0026quot;dlq137@gmail.com\u0026quot;  这里的设置将覆盖全局选项，并且只应用于当前的repo。\n更改最近一次提交的作者用户名和邮箱 如果你刚做了一次提交，发现用户名和邮箱并不是所要的，你可以使用--amend选项重新提交：\n$ git commit --amend --author=\u0026quot;Du Liqiang \u0026lt;dlq137@gmail.com\u0026gt;\u0026quot;  更改多次提交的作者用户名和邮箱 这个时候我们需要借助强大的rebase命令，首先我们找到上一次“好”的提交1，并假设其提交hash为0ad14fa5，执行：\n$ git rebase -i -p 0ad14fa5  此时我们会进入一个编辑器，将那些需要编辑的提交全标记为edit，接下来git会指导你完成每次提交的编辑，你需要做的就是执行：\n$ git commit --amend --author=\u0026quot;Du Liqiang \u0026lt;dlq137@gmail.com\u0026gt; --no-edit $ git rebase --continue  使用git filter-branch批量更改 除了以上交互式的更改方法，另一种方法是借助git的filter-branch命令，其允许你使用一个script批量处理大量的提交。\n如下命令筛选提交邮箱为WRONG_EMAIL的提交，并将其用户名和邮箱分别设置为NEW_NAME和NEW_EMAIL对应的值。\n$ git filter-branch --env-filter ' WRONG_EMAIL=\u0026quot;wrong@example.com\u0026quot; NEW_NAME=\u0026quot;New Name Value\u0026quot; NEW_EMAIL=\u0026quot;correct@example.com\u0026quot; if [ \u0026quot;$GIT_COMMITTER_EMAIL\u0026quot; = \u0026quot;$WRONG_EMAIL\u0026quot; ] then export GIT_COMMITTER_NAME=\u0026quot;$NEW_NAME\u0026quot; export GIT_COMMITTER_EMAIL=\u0026quot;$NEW_EMAIL\u0026quot; fi if [ \u0026quot;$GIT_AUTHOR_EMAIL\u0026quot; = \u0026quot;$WRONG_EMAIL\u0026quot; ] then export GIT_AUTHOR_NAME=\u0026quot;$NEW_NAME\u0026quot; export GIT_AUTHOR_EMAIL=\u0026quot;$NEW_EMAIL\u0026quot; fi ' --tag-name-filter cat -- --branches --tags  参考  https://www.git-tower.com/learn/git/faq/change-author-name-email    该次提交之前的提交具有正确的用户名和邮箱，其后的需要进行更改。 \u0026#x21a9;\u0026#xfe0e;\n  ","date":1573120043,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1573120043,"objectID":"9f6fd127ef1ad95f23bfd5dc1c97aaa2","permalink":"https://keris.github.io/zh/post/change-author-name-email/","publishdate":"2019-11-07T17:47:23+08:00","relpermalink":"/zh/post/change-author-name-email/","section":"post","summary":"在git的日常使用中更改提交的作者名和邮箱是一个十分常见的操作。例如，当你克隆了一个项目，如果你没有进行任何设置，此时提交的作者和邮件将使用全局选项，这可能不是你所要的。\n","tags":["git","change-author"],"title":"更改git提交中的作者和邮件信息","type":"post"}]