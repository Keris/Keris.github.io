<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杜利强</title>
    <link>https://keris.github.io/zh/</link>
      <atom:link href="https://keris.github.io/zh/index.xml" rel="self" type="application/rss+xml" />
    <description>杜利强</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Wed, 11 Mar 2020 19:20:11 +0800</lastBuildDate>
    <image>
      <url>https://keris.github.io/images/icon_hu0fc6cda6d9ee8f97aed5fca718c40606_62996_512x512_fill_lanczos_center_2.png</url>
      <title>杜利强</title>
      <link>https://keris.github.io/zh/</link>
    </image>
    
    <item>
      <title>评估指标</title>
      <link>https://keris.github.io/zh/post/metrics/</link>
      <pubDate>Wed, 11 Mar 2020 19:20:11 +0800</pubDate>
      <guid>https://keris.github.io/zh/post/metrics/</guid>
      <description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#混淆矩阵&#34;&gt;混淆矩阵&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#accuracy&#34;&gt;Accuracy&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#precision&#34;&gt;Precision&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#recall&#34;&gt;Recall&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#f1-score&#34;&gt;F1 score&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#f_beta-score&#34;&gt;$F_\beta$ score&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#roc-curve&#34;&gt;ROC Curve&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#auc&#34;&gt;AUC&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;混淆矩阵&#34;&gt;混淆矩阵&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;guessed positive&lt;/th&gt;
&lt;th&gt;guessed negative&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;positive&lt;/td&gt;
&lt;td&gt;true positives, #TP&lt;/td&gt;
&lt;td&gt;false negatives, #FN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;negative&lt;/td&gt;
&lt;td&gt;false positives, #FP&lt;/td&gt;
&lt;td&gt;true negatives, #TN&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设某个模型在一组样本上的表现如下：&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;model-performance.png&#34; &gt;
&lt;img data-src=&#34;model-performance.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;其中，蓝色的点为正例（positives)，橙色的点为负例（negatives），则混淆矩阵如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;guessed positive&lt;/th&gt;
&lt;th&gt;guessed negative&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;positive&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;negative&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;accuracy&#34;&gt;Accuracy&lt;/h2&gt;
&lt;p&gt;Accuracy，也就是准确率，表示样本中分类正确所占的比例。&lt;/p&gt;
&lt;p&gt;$$\text{Accuracy} = \frac{\text{#TP} + \text{#TN}}{\text{#TP} + \text{#FP} + \text{#TN} + \text{#FN}}$$&lt;/p&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#TP&lt;/code&gt;表示&lt;code&gt;true positive&lt;/code&gt;的数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#FP&lt;/code&gt;表示&lt;code&gt;false positive&lt;/code&gt;的数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#TN&lt;/code&gt;表示&lt;code&gt;true negative&lt;/code&gt;的数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#FN&lt;/code&gt;表示&lt;code&gt;false negative&lt;/code&gt;的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于图1中的模型，准确率计算如下：&lt;/p&gt;
&lt;p&gt;$$\text{Accuracy} = \frac{6 + 5}{6 + 1 + 5 + 2} = \frac{11}{14}= 78.57\%$$&lt;/p&gt;
&lt;p&gt;准确率在数据偏斜的情况下将不再适用。比如在下图所示的例子中：&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;credit-card-fraud.png&#34; &gt;
&lt;img data-src=&#34;credit-card-fraud.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;模型需要找出良好的交易，但我们的样本中绝大部分都是良好的交易，这导致无论我们的模型如何，它都具有很高的准确率，如图中所示为&lt;code&gt;99.83%&lt;/code&gt;！，此时准确率将不能够评估我们的模型。&lt;/p&gt;
&lt;h2 id=&#34;precision&#34;&gt;Precision&lt;/h2&gt;
&lt;p&gt;Precision即精度，表示在所有预测为正例的样本中有多少是真正例。&lt;/p&gt;
&lt;p&gt;$$\text{Precision} = \frac{\text{#TP}}{\text{#TP} + \text{#FP}}$$&lt;/p&gt;
&lt;p&gt;对于图1中的模型，精度计算如下：&lt;/p&gt;
&lt;p&gt;$$\text{Precision} = \frac{6}{6 + 2} = \frac{6}{8} = 75\%$$&lt;/p&gt;
&lt;h2 id=&#34;recall&#34;&gt;Recall&lt;/h2&gt;
&lt;p&gt;Recall即为召回率，所有的正例样本中真正例所占的比例：&lt;/p&gt;
&lt;p&gt;$$\text{Recall} = \frac{\text{#TP}}{\text{#TP} + \text{#FN}}$$&lt;/p&gt;
&lt;p&gt;对于图1中的模型，召回率计算如下：&lt;/p&gt;
&lt;p&gt;$$\text{Recall} = \frac{6}{6 + 1} = \frac{6}{7} = 85.71\%$$&lt;/p&gt;
&lt;h2 id=&#34;f1-score&#34;&gt;F1 score&lt;/h2&gt;
&lt;p&gt;F1-score定义如下：&lt;/p&gt;
&lt;p&gt;$$\text{F1} = 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}$$&lt;/p&gt;
&lt;p&gt;可以看到F1-score综合了精度和召回率，为精度和召回率的调和平均：&lt;strong&gt;在召回率不变的条件下，精度越高，F1-score越大；在精度不变的条件下，召回率越高，F1-score越大&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;f_beta-score&#34;&gt;$F_\beta$ score&lt;/h2&gt;
&lt;p&gt;$F_\beta-\text{score}$定义为：&lt;/p&gt;
&lt;p&gt;$$F_\beta = (1 + \beta^2) \times \frac{\text{Precision} \times \text{Recall}}{\beta^2 \times \text{Precision} + \text{Recall}}$$&lt;/p&gt;
&lt;p&gt;可以看出来，当$\beta = 1$时即为F1 score。&lt;/p&gt;
&lt;p&gt;下面我们看下$F_\beta$随$\beta$变化的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当$\beta = 0$时，通过计算不难得出$F_0 = \text{Precision}$;&lt;/li&gt;
&lt;li&gt;相反，当$\beta$取很大的值时，$F_\beta$将趋近召回率。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;小结：当$\beta$取较小的值时，精度比召回率重要，如$F_{0.5}$ score；当$\beta$取较大值时召回率比精度重要，如$F_2$ score。&lt;/p&gt;
&lt;h2 id=&#34;roc-curve&#34;&gt;ROC Curve&lt;/h2&gt;
&lt;p&gt;ROC Curve的全称为Receiver Operating Characteristic Curve，即受试者工作特性缺陷，它刻画了模型在所有分类阈值下的表现。&lt;/p&gt;
&lt;p&gt;要绘制该曲线，我们需要计算以下两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Positive Rate, TPR&lt;/li&gt;
&lt;li&gt;False Positive Rate, FPR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TPR，表示所有的正例样本中真正例的占比，不难发现，这其实跟召回率一个概念：&lt;/p&gt;
&lt;p&gt;$$\text{TPR} = \frac{\text{#TP}}{\text{#TP} + \text{#FN}}$$&lt;/p&gt;
&lt;p&gt;FPR，表示所有的负例样本中假正例的占比：&lt;/p&gt;
&lt;p&gt;$$\text{FPR} = \frac{\text{#FP}}{\text{#FP} + \text{#TN}}$$&lt;/p&gt;
&lt;p&gt;在不同的分类阈值下绘制TPR vs. FPR便得到ROC曲线：&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;ROCCurve.svg&#34; &gt;
&lt;img data-src=&#34;ROCCurve.svg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;auc&#34;&gt;AUC&lt;/h2&gt;
&lt;p&gt;AUC的全称为Area Under a ROC Curve，即ROC曲线下的面积。&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;AUC.png&#34; &gt;
&lt;img data-src=&#34;AUC.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

</description>
    </item>
    
    <item>
      <title>信用评分卡模型</title>
      <link>https://keris.github.io/zh/post/credit-score-card/</link>
      <pubDate>Tue, 03 Mar 2020 17:28:08 +0800</pubDate>
      <guid>https://keris.github.io/zh/post/credit-score-card/</guid>
      <description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#信用评分卡模型&#34;&gt;信用评分卡模型&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#评分卡模型划分&#34;&gt;评分卡模型划分&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#如何利用评分卡对用户进行评分&#34;&gt;如何利用评分卡对用户进行评分？&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#小结&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#评分卡模型的开发&#34;&gt;评分卡模型的开发&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#评分卡模型开发流程&#34;&gt;评分卡模型开发流程&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#数据获取&#34;&gt;数据获取&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#eda&#34;&gt;EDA&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#数据预处理&#34;&gt;数据预处理&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#数据清洗&#34;&gt;数据清洗&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#变量分箱&#34;&gt;变量分箱&lt;/a&gt;
              &lt;ul&gt;
                &lt;li&gt;&lt;a href=&#34;#无监督分箱&#34;&gt;无监督分箱&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;#有监督分箱&#34;&gt;有监督分箱&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;#小结-1&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;信用评分卡模型&#34;&gt;信用评分卡模型&lt;/h2&gt;
&lt;p&gt;信用评分卡模型是一种最常见的金融风控手段。它是指根据客户的各种属性和行为数据构建一个信用评分模型，对客户进行信用评分，并据此决定是否给予授信以及授信的额度和利率，从而识别和减少在金融交易中存在的交易风险。&lt;/p&gt;
&lt;p&gt;以下为评分卡模型的示意图：&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;credit-score-card-demo.png&#34; data-caption=&#34;Credit Score Card Demo&#34;&gt;
&lt;img data-src=&#34;credit-score-card-demo.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption data-pre=&#34;图&#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Credit Score Card Demo
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;评分卡模型划分&#34;&gt;评分卡模型划分&lt;/h3&gt;
&lt;p&gt;在不同的业务阶段我们可以构建不同的评分卡模型。根据借贷时间，评分卡模型可以划分为以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贷前：申请评分卡（Application score card），又称为A卡&lt;/li&gt;
&lt;li&gt;贷中：行为评分卡（Behavior score card），又称为B卡&lt;/li&gt;
&lt;li&gt;贷后：催收评分卡（Collection score card），又称为C卡&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何利用评分卡对用户进行评分&#34;&gt;如何利用评分卡对用户进行评分？&lt;/h3&gt;
&lt;p&gt;一个用户的评分等于基准分加上对客户各个属性的评分。对前面给出的示意图中的例子而言：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;客户评分 = 基准分 + 年龄评分 + 性别评分 + 婚姻状况评分 + 学历评分 + 月收入评分
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现有一客户，其年龄为27岁，性别男，已婚，本科学历，月收入为10k，那么他的评分为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;223(基准分) + 8(年龄评分) + 4(性别评分) + 8(婚姻状况评分) + 8(学历评分) + 13(月收入评分) = 264
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;以上就是评分卡模型的具体用法。在前面的例子中，不难发现以下三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何选择用户的属性？&lt;/li&gt;
&lt;li&gt;评分卡模型采用的是对属性的分段进行评分，那么如何进行有效的分段？&lt;/li&gt;
&lt;li&gt;如何对每个分段进行评分？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;评分卡模型的开发&#34;&gt;评分卡模型的开发&lt;/h2&gt;
&lt;h3 id=&#34;评分卡模型开发流程&#34;&gt;评分卡模型开发流程&lt;/h3&gt;
&lt;p&gt;信用评分卡模型的开发一般包括数据获取，EDA，数据预处理，变量筛选，模型开发及评估，生成评分卡模型，模型上线及监测。典型的开发流程图如下：&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;credit-score-card-flowchart.png&#34; data-caption=&#34;Credit Score Card Flowchart&#34;&gt;
&lt;img data-src=&#34;credit-score-card-flowchart.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;70%&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption data-pre=&#34;图&#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Credit Score Card Flowchart
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;数据获取&#34;&gt;数据获取&lt;/h4&gt;
&lt;p&gt;数据主要有两个来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;金融机构自有数据：如用户的年龄，户籍，性别，收入，负债比，在本机构的借款和还款行为等&lt;/li&gt;
&lt;li&gt;第三方数据：如用户在其他机构的借贷行为，用户的消费行为数据等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;eda&#34;&gt;EDA&lt;/h4&gt;
&lt;p&gt;EDA为&lt;a href=&#34;https://en.wikipedia.org/wiki/Exploratory_data_analysis&#34;&gt;Exploratory Data Analysis&lt;/a&gt;的简写，即探索性数据分析。这个阶段旨在了解数据的主要特性，如字段的缺失情况，异常值情况，中位数，分布等。最后制定一个合理的数据预处理方案。&lt;/p&gt;
&lt;h4 id=&#34;数据预处理&#34;&gt;数据预处理&lt;/h4&gt;
&lt;p&gt;数据预处理主要包括数据清洗，变量分箱和WOE编码。&lt;/p&gt;
&lt;h4 id=&#34;数据清洗&#34;&gt;数据清洗&lt;/h4&gt;
&lt;p&gt;数据清洗主要是对数据中的缺失值和异常值进行处理。一般我们选择删除缺失率超过某个阈值&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;（如30%，50%等）的变量。&lt;/p&gt;
&lt;h4 id=&#34;变量分箱&#34;&gt;变量分箱&lt;/h4&gt;
&lt;p&gt;所谓的分箱定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对连续变量进行分段以离散化&lt;/li&gt;
&lt;li&gt;将离散变量的多个状态进行合并，减少离散变量的状态数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过分箱操作，我们达到了对变量分段的目的。&lt;/p&gt;
&lt;p&gt;常见的分箱类型如下：&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;binning.png&#34; data-caption=&#34;常见的变量分箱类型&#34;&gt;
&lt;img data-src=&#34;binning.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption data-pre=&#34;图&#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    常见的变量分箱类型
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h5 id=&#34;无监督分箱&#34;&gt;无监督分箱&lt;/h5&gt;
&lt;p&gt;无监督分箱主要包括三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等频分箱：把自变量的值按从小到大排序，将自变量的取值个数等分为&lt;code&gt;k&lt;/code&gt;部分，每部分作为一个分箱&lt;/li&gt;
&lt;li&gt;等距分箱：把自变量的值按从小到大排序，将自变量的取值范围分为&lt;code&gt;k&lt;/code&gt;个等距的区间，每个区间作为一个分箱&lt;/li&gt;
&lt;li&gt;聚类分箱：用&lt;code&gt;k-means&lt;/code&gt;等聚类法将自变量分为&lt;code&gt;k&lt;/code&gt;类，但需要在聚类过程中保证分箱的有序性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt; 无监督分箱仅考虑了各个变量自身的结构，并没有考虑自变量与目标变量之间的关系，因此这种分箱方法不一定会带来模型性能的提升。&lt;/p&gt;
&lt;h5 id=&#34;有监督分箱&#34;&gt;有监督分箱&lt;/h5&gt;
&lt;p&gt;有监督分箱主要包括Split分箱和Merge分箱。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Split分箱是一种自上而下的分箱方法，其和决策树比较相似，切分点的选择指标主要有entropy， gini指数和IV值等。&lt;/li&gt;
&lt;li&gt;Merge分箱是一种自下而上的分箱方法，常见的merge分箱为ChiMerge分箱。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ChiMerge分箱的基本思想是：&lt;em&gt;如果两个相邻区间具有相似的类分布，则合并它们，否则保持不变。ChiMerge通常采用卡方值来度量两相邻区间的类分布的相似性。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;计算卡方值的公式如下：&lt;/p&gt;
&lt;p&gt;$$
\chi^2 = \sum_{i=1}^2 \sum_{j=1}^k \frac{(A_{ij} - E_{ij})^2}{E_{ij}}
$$&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;$k =$ 类别数目&lt;/p&gt;
&lt;p&gt;$A_{ij} =$ 第 $i$ 个区间中第$j$个类别的样本数目&lt;/p&gt;
&lt;p&gt;$E_{ij} = A_{ij}$的期望频率$=\frac{R_i \times C_j}{N}$，$R_i =$第$i$区间的样本数目$= \sum_{j=1}^k A_{ij}$，$C_j = $第$j$个类别的样本数目$= \sum_{i=1}^2 A_{ij}$&lt;/p&gt;
&lt;p&gt;ChiMerge算法包含一个初始化步和一个自底向上的合并过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化：将需要离散化的属性的值按从小到大排序，将每个样本作为一个区间&lt;/li&gt;
&lt;li&gt;合并区间
&lt;ol&gt;
&lt;li&gt;计算每对相邻区间的$\chi^2$&lt;/li&gt;
&lt;li&gt;合并具有最小$\chi^2$的相邻区间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果所有相邻区间对的$\chi^2$超过了$\chi^2-threshold$，则停止，否则回到第2步&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何确定$\chi^2-threshold$？为此我们需要选择一个想要的显著性水平和自有度，然后通过查表或者公式获得对应的$\chi^2$。其中自由度为&lt;code&gt;类别数目 - 1&lt;/code&gt;，例如，当有3个类别时，自由度为2。&lt;/p&gt;
&lt;p&gt;除了使用$\chi^2-threshold$，还可以指定&lt;code&gt;最小区间数&lt;/code&gt;和&lt;code&gt;最大区间数&lt;/code&gt;来确保不会产生太少或者太多的区间。&lt;/p&gt;
&lt;p&gt;在金融风控中，当我们应用ChiMerge时，在初始化时往往有以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续值按升序排列，离散值首先转化为坏客户的占比，然后再按升序排列&lt;/li&gt;
&lt;li&gt;为了减少计算量，对于状态数大于某一阈值（建议为100）的变量，利用等频分箱进行粗分箱&lt;/li&gt;
&lt;li&gt;若有缺失值，则缺失值单独作为一个分箱&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在分箱完后还会做进一步的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于坏客户占比为0或者1的分箱进行合并（一个分箱内不能全为好客户或者坏客户）&lt;/li&gt;
&lt;li&gt;对于样本占比超过95%的箱子进行删除&lt;/li&gt;
&lt;li&gt;检查缺失分箱的坏客户比例是否和非缺失分箱相等，如果相等，进行合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;小结-1&#34;&gt;小结&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;分箱可以有效处理缺失值和异常值&lt;/li&gt;
&lt;li&gt;分箱后数据和模型会更稳定&lt;/li&gt;
&lt;li&gt;分箱可以简化逻辑回归模型，降低过拟合风险，提高泛化能力&lt;/li&gt;
&lt;li&gt;分箱将特征统一变换为类别型变量&lt;/li&gt;
&lt;li&gt;分箱后变量才可以使用标准的评分卡格式&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;阈值的选择需要根据实际情况确定。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>RFM模型及实践</title>
      <link>https://keris.github.io/zh/post/what-is-rfm-model/</link>
      <pubDate>Wed, 26 Feb 2020 15:41:30 +0800</pubDate>
      <guid>https://keris.github.io/zh/post/what-is-rfm-model/</guid>
      <description>&lt;p&gt;RFM是一种用于分析客户价值的方法，常用于营销。其中RFM代表三个维度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;ecency 表示最近一次客户购买的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;requency 表示在统计周期内客户购买的次数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M&lt;/strong&gt;onetary Value 表示统计周期内客户消费的总金额&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我们使用RFM模型分析一个真实的&lt;a href=&#34;https://www.kaggle.com/carrie1/ecommerce-data#data.csv&#34;&gt;在线购物数据&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Import libraries
import pandas as pd
import matplotlib.pyplot as plt
import squarify
from datetime import timedelta
import seaborn as sns
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Read dataset
online = pd.read_csv(&#39;data.csv&#39;, encoding=&#39;ISO-8859-1&#39;)
online.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/style&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;InvoiceNo&lt;/th&gt;
      &lt;th&gt;StockCode&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
      &lt;th&gt;Quantity&lt;/th&gt;
      &lt;th&gt;InvoiceDate&lt;/th&gt;
      &lt;th&gt;UnitPrice&lt;/th&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;Country&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;536365&lt;/td&gt;
      &lt;td&gt;85123A&lt;/td&gt;
      &lt;td&gt;WHITE HANGING HEART T-LIGHT HOLDER&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;12/1/2010 8:26&lt;/td&gt;
      &lt;td&gt;2.55&lt;/td&gt;
      &lt;td&gt;17850.0&lt;/td&gt;
      &lt;td&gt;United Kingdom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;536365&lt;/td&gt;
      &lt;td&gt;71053&lt;/td&gt;
      &lt;td&gt;WHITE METAL LANTERN&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;12/1/2010 8:26&lt;/td&gt;
      &lt;td&gt;3.39&lt;/td&gt;
      &lt;td&gt;17850.0&lt;/td&gt;
      &lt;td&gt;United Kingdom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;536365&lt;/td&gt;
      &lt;td&gt;84406B&lt;/td&gt;
      &lt;td&gt;CREAM CUPID HEARTS COAT HANGER&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;12/1/2010 8:26&lt;/td&gt;
      &lt;td&gt;2.75&lt;/td&gt;
      &lt;td&gt;17850.0&lt;/td&gt;
      &lt;td&gt;United Kingdom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;536365&lt;/td&gt;
      &lt;td&gt;84029G&lt;/td&gt;
      &lt;td&gt;KNITTED UNION FLAG HOT WATER BOTTLE&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;12/1/2010 8:26&lt;/td&gt;
      &lt;td&gt;3.39&lt;/td&gt;
      &lt;td&gt;17850.0&lt;/td&gt;
      &lt;td&gt;United Kingdom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;536365&lt;/td&gt;
      &lt;td&gt;84029E&lt;/td&gt;
      &lt;td&gt;RED WOOLLY HOTTIE WHITE HEART.&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;12/1/2010 8:26&lt;/td&gt;
      &lt;td&gt;3.39&lt;/td&gt;
      &lt;td&gt;17850.0&lt;/td&gt;
      &lt;td&gt;United Kingdom&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;online.dtypes
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;InvoiceNo       object
StockCode       object
Description     object
Quantity         int64
InvoiceDate     object
UnitPrice      float64
CustomerID     float64
Country         object
dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Convert InvoiceDate from object to datetime format
online[&#39;InvoiceDate&#39;] = pd.to_datetime(online[&#39;InvoiceDate&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;online.dtypes
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;InvoiceNo              object
StockCode              object
Description            object
Quantity                int64
InvoiceDate    datetime64[ns]
UnitPrice             float64
CustomerID            float64
Country                object
dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Check how many rows and columns
online.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(541909, 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Count transactions that don&#39;t have a customer id
print(&#39;{:,} transactions don\&#39;t have a customer id&#39;
     .format(online[online.CustomerID.isnull()].shape[0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;135,080 transactions don&#39;t have a customer id
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Check invoice date range
print(&#39;Transactions timeframe from {} to {}&#39;
     .format(online.InvoiceDate.min(), online.InvoiceDate.max()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Transactions timeframe from 2010-12-01 08:26:00 to 2011-12-09 12:50:00
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Drop NA values from online
online.dropna(inplace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Group data by CustomerID

# Create TotalSum column for online dataset
online[&#39;TotalSum&#39;] = online[&#39;Quantity&#39;] * online[&#39;UnitPrice&#39;]

# Create snapshot date
snapshot_date = online.InvoiceDate.max() + timedelta(days=1)
print(snapshot_date)

# Group by CustomerID
data = online.groupby([&#39;CustomerID&#39;]).agg({
    &#39;InvoiceDate&#39;: lambda x: (snapshot_date - x.max()).days,
    &#39;InvoiceNo&#39;: &#39;count&#39;,
    &#39;TotalSum&#39;: &#39;sum&#39;
})

data.rename(columns={&#39;InvoiceDate&#39;: &#39;Recency&#39;,
                     &#39;InvoiceNo&#39;: &#39;Frequency&#39;,
                     &#39;TotalSum&#39;: &#39;MonetaryValue&#39;}, inplace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2011-12-10 12:50:00
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Peek first 5 rows
data.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/style&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Recency&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
      &lt;th&gt;MonetaryValue&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;12346.0&lt;/th&gt;
      &lt;td&gt;326&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12347.0&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;182&lt;/td&gt;
      &lt;td&gt;4310.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12348.0&lt;/th&gt;
      &lt;td&gt;75&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;1797.24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12349.0&lt;/th&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;1757.55&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12350.0&lt;/th&gt;
      &lt;td&gt;310&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;334.40&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Check how many rows and columns
data.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(4372, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里我们可以看到，根据CutomerID进行分组后，我们聚合生成了每个客户最近一次购买的时间，购买频率和消费额度，共4372条记录。接下来，我们需要对这三个维度进行打分，这可以通过&lt;code&gt;.qcut()&lt;/code&gt;来进行。但在此之前，我们先看一看特征的分布情况。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Plot RFM distributions
plt.figure(figsize=(12,10))

# Plot distribution of R
plt.subplot(3, 1, 1)
sns.distplot(data[&#39;Recency&#39;])

# Plot distribution of F
plt.subplot(3, 1, 2)
sns.distplot(data[&#39;Frequency&#39;])

# Plot distribution of M
plt.subplot(3, 1, 3)
sns.distplot(data[&#39;MonetaryValue&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x1199779b0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_13_1.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Calculate R and F groups

# Create labels for Recency and Frequency
r_labels = range(4, 0, -1)
f_labels = range(1, 5)

# Assign these labels to 4 equal percentil groups
r_groups = pd.qcut(data[&#39;Recency&#39;], q=4, labels=r_labels)

f_groups = pd.qcut(data[&#39;Frequency&#39;], q=4, labels=f_labels)

# Create new columns R and F
data = data.assign(R=r_groups.values, F=f_groups.values)
data.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/style&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Recency&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
      &lt;th&gt;MonetaryValue&lt;/th&gt;
      &lt;th&gt;R&lt;/th&gt;
      &lt;th&gt;F&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;12346.0&lt;/th&gt;
      &lt;td&gt;326&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0.00&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12347.0&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;182&lt;/td&gt;
      &lt;td&gt;4310.00&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12348.0&lt;/th&gt;
      &lt;td&gt;75&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;1797.24&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12349.0&lt;/th&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;1757.55&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12350.0&lt;/th&gt;
      &lt;td&gt;310&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;334.40&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Create labels form MonetaryValue
m_labels = range(1, 5)
m_groups = pd.qcut(data[&#39;MonetaryValue&#39;], q=4, labels=m_labels)
data = data.assign(M=m_groups.values)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/style&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Recency&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
      &lt;th&gt;MonetaryValue&lt;/th&gt;
      &lt;th&gt;R&lt;/th&gt;
      &lt;th&gt;F&lt;/th&gt;
      &lt;th&gt;M&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;12346.0&lt;/th&gt;
      &lt;td&gt;326&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0.00&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12347.0&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;182&lt;/td&gt;
      &lt;td&gt;4310.00&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12348.0&lt;/th&gt;
      &lt;td&gt;75&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;1797.24&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12349.0&lt;/th&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;1757.55&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12350.0&lt;/th&gt;
      &lt;td&gt;310&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;334.40&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Concat RFM quartile values to create RFM segments
def join_rfm(x):
    return str(x[&#39;R&#39;]) + str(x[&#39;F&#39;]) + str(x[&#39;M&#39;])

data[&#39;RFM_segment_concat&#39;] = data.apply(join_rfm, axis=1)
rfm = data
rfm.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/style&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Recency&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
      &lt;th&gt;MonetaryValue&lt;/th&gt;
      &lt;th&gt;R&lt;/th&gt;
      &lt;th&gt;F&lt;/th&gt;
      &lt;th&gt;M&lt;/th&gt;
      &lt;th&gt;RFM_segment_concat&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;12346.0&lt;/th&gt;
      &lt;td&gt;326&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0.00&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;111&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12347.0&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;182&lt;/td&gt;
      &lt;td&gt;4310.00&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;444&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12348.0&lt;/th&gt;
      &lt;td&gt;75&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;1797.24&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;224&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12349.0&lt;/th&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;1757.55&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;334&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12350.0&lt;/th&gt;
      &lt;td&gt;310&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;334.40&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;112&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Count num of unique segments
rfm_count_unique = rfm.groupby(&#39;RFM_segment_concat&#39;)[&#39;RFM_segment_concat&#39;].nunique()
print(rfm_count_unique.sum())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;62
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上结果显示，将RFM连接在一起这种方法共形成62个划分，但划分太多了不能用于实际应用。下面我们尝试将这三个值相加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Calculate RFM_Score
rfm[&#39;RFM_Score&#39;] = rfm[[&#39;R&#39;, &#39;F&#39;, &#39;M&#39;]].sum(axis=1)
print(rfm[&#39;RFM_Score&#39;].head())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CustomerID
12346.0     3.0
12347.0    12.0
12348.0     8.0
12349.0    10.0
12350.0     4.0
Name: RFM_Score, dtype: float64
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Define rfm_level function
def rfm_level(df):
    if df[&#39;RFM_Score&#39;] &amp;gt;= 9:
        return &#39;Can\&#39;t Loose Them&#39;
    elif ((df[&#39;RFM_Score&#39;] &amp;gt;= 8) and (df[&#39;RFM_Score&#39;] &amp;lt; 9)):
        return &#39;Champions&#39;
    elif ((df[&#39;RFM_Score&#39;] &amp;gt;= 7) and (df[&#39;RFM_Score&#39;] &amp;lt; 8)):
        return &#39;Loyal&#39;
    elif ((df[&#39;RFM_Score&#39;] &amp;gt;= 6) and (df[&#39;RFM_Score&#39;] &amp;lt; 7)):
        return &#39;Potential&#39;
    elif ((df[&#39;RFM_Score&#39;] &amp;gt;= 5) and (df[&#39;RFM_Score&#39;] &amp;lt; 6)):
        return &#39;Promising&#39;
    elif ((df[&#39;RFM_Score&#39;] &amp;gt;= 4) and (df[&#39;RFM_Score&#39;] &amp;lt; 5)):
        return &#39;Needs Attention&#39;
    else:
        return &#39;Require Activation&#39;

# Create a new variable RFM_Level
rfm[&#39;RFM_Level&#39;] = rfm.apply(rfm_level, axis=1)

rfm.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/style&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Recency&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
      &lt;th&gt;MonetaryValue&lt;/th&gt;
      &lt;th&gt;R&lt;/th&gt;
      &lt;th&gt;F&lt;/th&gt;
      &lt;th&gt;M&lt;/th&gt;
      &lt;th&gt;RFM_segment_concat&lt;/th&gt;
      &lt;th&gt;RFM_Score&lt;/th&gt;
      &lt;th&gt;RFM_Level&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;12346.0&lt;/th&gt;
      &lt;td&gt;326&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0.00&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;111&lt;/td&gt;
      &lt;td&gt;3.0&lt;/td&gt;
      &lt;td&gt;Require Activation&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12347.0&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;182&lt;/td&gt;
      &lt;td&gt;4310.00&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;444&lt;/td&gt;
      &lt;td&gt;12.0&lt;/td&gt;
      &lt;td&gt;Can&#39;t Loose Them&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12348.0&lt;/th&gt;
      &lt;td&gt;75&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;1797.24&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;224&lt;/td&gt;
      &lt;td&gt;8.0&lt;/td&gt;
      &lt;td&gt;Champions&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12349.0&lt;/th&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;1757.55&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;334&lt;/td&gt;
      &lt;td&gt;10.0&lt;/td&gt;
      &lt;td&gt;Can&#39;t Loose Them&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12350.0&lt;/th&gt;
      &lt;td&gt;310&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;334.40&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;112&lt;/td&gt;
      &lt;td&gt;4.0&lt;/td&gt;
      &lt;td&gt;Needs Attention&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Calculate average values for each RFM_Level, and return a size of each segment
rfm_level_agg = rfm.groupby(&#39;RFM_Level&#39;).agg({
    &#39;Recency&#39;: &#39;mean&#39;,
    &#39;Frequency&#39;: &#39;mean&#39;,
    &#39;MonetaryValue&#39;: [&#39;mean&#39;, &#39;count&#39;]
}).round(1)

# Print the aggregate dataset
print(rfm_level_agg)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;                   Recency Frequency MonetaryValue
                      mean      mean          mean count
RFM_Level
Can&#39;t Loose Them      25.2     195.1        4130.3  1690
Champions             62.7      57.0         974.7   467
Loyal                 78.8      39.7         724.2   447
Needs Attention      174.5      13.9         227.1   391
Potential             94.3      28.5         491.8   468
Promising            153.0      21.2         346.8   517
Require Activation   264.8       7.8         109.1   392
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从以上结果我们可以看到，约60%的客户属于优质客户（前三类用户）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Visualize segments
rfm_level_agg.columns = rfm_level_agg.columns.droplevel()
rfm_level_agg.columns = [&#39;RecencyMean&#39;, &#39;FrequencyMean&#39;, &#39;MonetaryMean&#39;, &#39;Count&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Create our plot and resize it
fig = plt.gcf()
ax = fig.add_subplot()
fig.set_size_inches(16, 9)

squarify.plot(sizes=rfm_level_agg[&#39;Count&#39;], label=list(rfm_level_agg.index), alpha=.6)
plt.title(&#39;RFM Segments&#39;, fontsize=18, fontweight=&#39;bold&#39;)
plt.axis(&#39;off&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_25_0.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>逻辑回归（Logistic Regression）</title>
      <link>https://keris.github.io/zh/post/logistic-regression/</link>
      <pubDate>Tue, 14 Jan 2020 16:47:22 +0800</pubDate>
      <guid>https://keris.github.io/zh/post/logistic-regression/</guid>
      <description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#术语&#34;&gt;术语&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#logistic-function&#34;&gt;Logistic function&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#odds&#34;&gt;Odds&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#logit-function&#34;&gt;Logit function&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#逻辑回归&#34;&gt;逻辑回归&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#代价函数求导&#34;&gt;代价函数求导&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;
&lt;p&gt;逻辑回归涉及到以下术语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logistic function&lt;/li&gt;
&lt;li&gt;Odds&lt;/li&gt;
&lt;li&gt;Logit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;logistic-function&#34;&gt;Logistic function&lt;/h3&gt;
&lt;p&gt;逻辑回归中的 &lt;em&gt;Logistic&lt;/em&gt; 正是出于 &lt;em&gt;Logistic function&lt;/em&gt; ，它是一种 &lt;em&gt;sigmoid function&lt;/em&gt; ，其接受任意实值，输出一个0到1之间的值。
&lt;em&gt;标准的&lt;/em&gt; logistic funtion 定义如下：&lt;/p&gt;
&lt;p&gt;$$\sigma(z) = \frac{e^z}{e^z + 1} = \frac{1}{1 + e^{-z}}$$&lt;/p&gt;
&lt;p&gt;如下是它在区间$[-6, 6]$之间的图像：&lt;/p&gt;
&lt;p&gt;&lt;a title=&#34;logistic function curve&#34; href=&#34;https://commons.wikimedia.org/wiki/File:Logistic-curve.svg&#34;&gt;&lt;img width=&#34;512&#34; alt=&#34;Logistic-curve&#34; src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/512px-Logistic-curve.svg.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在逻辑回归中，我们使用对数几率（log odds），&lt;strong&gt;并假定它是输入特征的线性组合&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$z = \ln \frac{p(x)}{1 - p(x)}= \theta_0 + \theta_1 x_1 + \theta_2 x_2 = \theta^T \cdot x$$&lt;/p&gt;
&lt;p&gt;由上式我们可以得到，&lt;/p&gt;
&lt;p&gt;$$p(x) = \sigma(z) = \frac{1}{1 + e^{-\theta^T \cdot x}}$$&lt;/p&gt;
&lt;p&gt;在逻辑回归模型中，这里的 $p(x)$ 为因变量在成功情形下的概率，即 $p(y=1 \mid x)$。&lt;/p&gt;
&lt;h3 id=&#34;odds&#34;&gt;Odds&lt;/h3&gt;
&lt;p&gt;如果 $p$ 表示一个事件发生的概率，那么odds定义为&lt;/p&gt;
&lt;p&gt;$$\text{odds} = \frac{p}{1 - p}$$
也就是说，odds为发生的概率除以不发生的概率，亦可以说为成功的概率除以失败的概率。&lt;/p&gt;
&lt;h3 id=&#34;logit-function&#34;&gt;Logit function&lt;/h3&gt;
&lt;p&gt;Logit为Log odds, logit function 定义为 logistic function的逆，即 $g = \sigma^{-1}$。显而易见，我们有&lt;/p&gt;
&lt;p&gt;$$g(p(x)) = \sigma_{-1}(p(x)) = \text{logit}\,p(x) = \ln(\frac{p(x)}{1 - p(x)}) = \theta^T \cdot x$$&lt;/p&gt;
&lt;h2 id=&#34;逻辑回归&#34;&gt;逻辑回归&lt;/h2&gt;
&lt;p&gt;逻辑回归是一个重要的机器学习算法，其目标是基于给定的数据$x$输出随机变量$y$为0或1的概率。&lt;/p&gt;
&lt;p&gt;考虑由$\theta$参数化的线性模型，&lt;/p&gt;
&lt;p&gt;$$h_\theta(x) = \frac{1}{1 + e^{-\theta^T \cdot x}} = \text{Pr}(y = 1 \mid x;\theta)$$&lt;/p&gt;
&lt;p&gt;从而，$\text{Pr}(y=0 \mid x;\theta) = 1 - h_\theta(x)$。&lt;/p&gt;
&lt;p&gt;因为$y \in \{0, 1 \}$，我们有&lt;/p&gt;
&lt;p&gt;$$\text{Pr}(y \mid x;\theta) = h_\theta(x)^y (1 - h_\theta(x))^{1 - y}
$$&lt;/p&gt;
&lt;p&gt;似然函数为&lt;/p&gt;
&lt;p&gt;$$\begin{aligned} L(\theta \mid x) &amp;amp;= \Pr(Y\mid X;\theta) \\&lt;br&gt;
&amp;amp;= \prod_i \Pr(y^{(i)} \mid x^{(i)};\theta) \\&lt;br&gt;
&amp;amp;= \prod_i h_\theta(x^{(i)})^{y^{(i)}}(1-h_\theta(x^{(i)}))^{1-y^{(i)}} \end{aligned}$$&lt;/p&gt;
&lt;p&gt;一般地，我们最大化对数似然函数，&lt;/p&gt;
&lt;p&gt;$$\log L(\theta \mid x) = \sum_{i=1}^{m}\log \Pr(y^{(i)} \mid x^{(i)};\theta)$$&lt;/p&gt;
&lt;p&gt;定义代价函数如下：&lt;/p&gt;
&lt;p&gt;$$J(\theta) = -\frac{1}{m} \log L(\theta \mid x) = -\frac{1}{m} \sum_i^m (y^{(i)} \log h_\theta(x^{(i)}) + (1 - y^{(i)})(1 - h_\theta(x^{(i)})))$$&lt;/p&gt;
&lt;p&gt;容易看到，我们最大化对数似然函数就是最小化代价函数 $J(\theta)$。在机器学习中，我们使用梯度下降最小化代价函数。&lt;/p&gt;
&lt;h3 id=&#34;代价函数求导&#34;&gt;代价函数求导&lt;/h3&gt;
&lt;p&gt;下面我们对代价函数$J(\theta)$对$\theta$进行求导，我们先考虑在一个样本上的代价函数&lt;/p&gt;
&lt;p&gt;$$J_1(\theta) = -y \log h_\theta(x) - (1 - y)(1 - h_\theta(x))$$&lt;/p&gt;
&lt;p&gt;现在对$J_1(\theta)$对$\theta$进行求导：&lt;/p&gt;
&lt;p&gt;注意到$\frac{d\sigma(z)}{dz} = \sigma(z) (1 - \sigma(z))$, 我们有&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}\frac{\partial}{\partial \theta_j} J_1(\theta) &amp;amp;= -y \frac{1}{h_\theta(x)} h_\theta(x) (1 - h_\theta(x)) x_j - (1 - y) \frac{1}{1 - h_\theta(x)} (-1) h_\theta(x) (1 - h_\theta(x)) x_j \\ &amp;amp;= (h_\theta(x) - y) x_j\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;有了以上结果，我们有&lt;/p&gt;
&lt;p&gt;$$\frac{\partial}{\partial \theta_j} J(\theta) = \frac{1}{m}\sum_i^m [h_\theta(x^{(i)}) - y^{(i)}]x_j^{(i)}$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>更改git提交中的作者和邮件信息</title>
      <link>https://keris.github.io/zh/post/change-author-name-email/</link>
      <pubDate>Thu, 07 Nov 2019 17:47:23 +0800</pubDate>
      <guid>https://keris.github.io/zh/post/change-author-name-email/</guid>
      <description>&lt;p&gt;在git的日常使用中更改提交的作者名和邮箱是一个十分常见的操作。例如，当你克隆了一个项目，如果你没有进行任何设置，此时提交的作者和邮件将使用全局选项，这可能不是你所要的。&lt;/p&gt;
&lt;p&gt;通过本文你将了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何配置git使用的提交者用户名和邮箱&lt;/li&gt;
&lt;li&gt;如何更改最近一次提交的作者名和邮件&lt;/li&gt;
&lt;li&gt;批量更改提交的作者名和邮件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置提交者用户名和邮箱&#34;&gt;配置提交者用户名和邮箱&lt;/h2&gt;
&lt;p&gt;你有两种方式进行设置，一是全局配置，二是为每个repo单独配置。&lt;/p&gt;
&lt;h3 id=&#34;全局地更改提交者用户名和邮箱&#34;&gt;全局地更改提交者用户名和邮箱&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;git config&lt;/code&gt;并&lt;code&gt;--global&lt;/code&gt;选项进行全局设置，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ git config --global user.name &amp;quot;Du Liqiang&amp;quot;
$ git config --global user.email &amp;quot;dlq137@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置完毕后，后续的提交将使用以上提供的信息。&lt;/p&gt;
&lt;h3 id=&#34;为某个repo单独配置&#34;&gt;为某个repo单独配置&lt;/h3&gt;
&lt;p&gt;全局选项可能并不适用于某个repo，此时就需要单独设置，使用&lt;code&gt;git config&lt;/code&gt;但省略&lt;code&gt;--global&lt;/code&gt;选项，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ git config user.name &amp;quot;Du Liqiang&amp;quot;
$ git config user.email &amp;quot;dlq137@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的设置将覆盖全局选项，并且只应用于当前的repo。&lt;/p&gt;
&lt;h2 id=&#34;更改最近一次提交的作者用户名和邮箱&#34;&gt;更改最近一次提交的作者用户名和邮箱&lt;/h2&gt;
&lt;p&gt;如果你刚做了一次提交，发现用户名和邮箱并不是所要的，你可以使用&lt;code&gt;--amend&lt;/code&gt;选项重新提交：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ git commit --amend --author=&amp;quot;Du Liqiang &amp;lt;dlq137@gmail.com&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更改多次提交的作者用户名和邮箱&#34;&gt;更改多次提交的作者用户名和邮箱&lt;/h2&gt;
&lt;p&gt;这个时候我们需要借助强大的&lt;code&gt;rebase&lt;/code&gt;命令，首先我们找到上一次“好”的提交&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，并假设其提交hash为&lt;code&gt;0ad14fa5&lt;/code&gt;，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ git rebase -i -p 0ad14fa5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时我们会进入一个编辑器，将那些需要编辑的提交全标记为&lt;code&gt;edit&lt;/code&gt;，接下来git会指导你完成每次提交的编辑，你需要做的就是执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit --amend --author=&amp;quot;Du Liqiang &amp;lt;dlq137@gmail.com&amp;gt; --no-edit
$ git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用git-filter-branch批量更改&#34;&gt;使用git filter-branch批量更改&lt;/h2&gt;
&lt;p&gt;除了以上交互式的更改方法，另一种方法是借助git的&lt;code&gt;filter-branch&lt;/code&gt;命令，其允许你使用一个script批量处理大量的提交。&lt;/p&gt;
&lt;p&gt;如下命令筛选提交邮箱为WRONG_EMAIL的提交，并将其用户名和邮箱分别设置为NEW_NAME和NEW_EMAIL对应的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ git filter-branch --env-filter &#39;
WRONG_EMAIL=&amp;quot;wrong@example.com&amp;quot;
NEW_NAME=&amp;quot;New Name Value&amp;quot;
NEW_EMAIL=&amp;quot;correct@example.com&amp;quot;

if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$WRONG_EMAIL&amp;quot; ]
then
    export GIT_COMMITTER_NAME=&amp;quot;$NEW_NAME&amp;quot;
    export GIT_COMMITTER_EMAIL=&amp;quot;$NEW_EMAIL&amp;quot;
fi
if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$WRONG_EMAIL&amp;quot; ]
then
    export GIT_AUTHOR_NAME=&amp;quot;$NEW_NAME&amp;quot;
    export GIT_AUTHOR_EMAIL=&amp;quot;$NEW_EMAIL&amp;quot;
fi
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.git-tower.com/learn/git/faq/change-author-name-email&#34;&gt;https://www.git-tower.com/learn/git/faq/change-author-name-email&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;该次提交之前的提交具有正确的用户名和邮箱，其后的需要进行更改。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
  </channel>
</rss>
